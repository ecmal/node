/**
 * A parsed path object generated by path.parse() or consumed by path.format().
 */
export interface PathObject {
    /**
     * The root of the path such as '/' or 'c:\'
     */
    root: string;
    /**
     * The full directory path such as '/home/user/dir' or 'c:\path\dir'
     */
    dir: string;
    /**
     * The file name including extension (if any) such as 'index.html'
     */
    base: string;
    /**
     * The file extension (if any) such as '.html'
     */
    ext: string;
    /**
     * The file name without extension (if any) such as 'index'
     */
    name: string;
}
/**
 * The platform-specific file separator. '\\' or '/'.
 */
export declare var sep: string;
/**
 * The platform-specific file delimiter. ';' or ':'.
 */
export declare var delimiter: string;

/**
 * Normalize a string path, reducing '..' and '.' parts.
 * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.
 *
 * @param p string path to normalize.
 */
export declare function normalize(p: string): string;
/**
 * Join all arguments together and normalize the resulting path.
 * Arguments must be strings. In v0.8, non-string arguments were silently ignored. In v0.10 and up, an exception is thrown.
 *
 * @param paths paths to join.
 */
export declare function join(...paths: string[]): string;
/**
 * The right-most parameter is considered {to}.  Other parameters are considered an array of {from}.
 *
 * Starting from leftmost {from} paramter, resolves {to} to an absolute path.
 *
 * If {to} isn't already absolute, {from} arguments are prepended in right to left order, until an absolute path is found. If after using all {from} paths still no absolute path is found, the current working directory is used as well. The resulting path is normalized, and trailing slashes are removed unless the path gets resolved to the root directory.
 *
 * @param pathSegments string paths to join.  Non-string arguments are ignored.
 */
export declare function resolve(...pathSegments: any[]): string;
/**
 * Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.
 *
 * @param path path to test.
 */
export declare function isAbsolute(path: string): boolean;
/**
 * Solve the relative path from {from} to {to}.
 * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.
 *
 * @param from
 * @param to
 */
export declare function relative(from: string, to: string): string;
/**
 * Return the directory name of a path. Similar to the Unix dirname command.
 *
 * @param p the path to evaluate.
 */
export declare function dirname(p: string): string;
/**
 * Return the last portion of a path. Similar to the Unix basename command.
 * Often used to extract the file name from a fully qualified path.
 *
 * @param p the path to evaluate.
 * @param ext optionally, an extension to remove from the result.
 */
export declare function basename(p: string, ext?: string): string;
/**
 * Return the extension of the path, from the last '.' to end of string in the last portion of the path.
 * If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string
 *
 * @param p the path to evaluate.
 */
export declare function extname(p: string): string;

/**
 * Returns an object from a path string - the opposite of format().
 *
 * @param pathString path to evaluate.
 */
export declare function parse(pathString: string): PathObject;
/**
 * Returns a path string from an object - the opposite of parse().
 *
 * @param pathString path to evaluate.
 */
export declare function format(pathObject: PathObject): string;

const binding = require('url');


export class Path implements PathObject {
    static sep: string = binding.sep;
    static del: string = binding.delimiter;
    static normalize(path: string): string {
        return binding.normalize(path)
    }
    static join(...paths: string[]): string {
        return binding.join(...paths);
    }
    static resolve(...segments: any[]): string {
        return binding.resolve(...segments);
    }
    static isAbsolute(path: string): boolean {
        return binding.isAbsolute(path);
    }
    static relative(from: string, to: string): string {
        return binding.relative(from, to);
    }
    static basename(path: string, ext?: string): string {
        return binding.basename(path, ext);
    }
    static extname(path: string): string {
        return binding.extname(path);
    }
    static format(path: PathObject): string {
        return binding.format(path);
    }
    static parse(path: string): Path {
        return Object.setPrototypeOf(binding.parse(path), Path.prototype);
    }
    public format(): string {
        return Path.format(this);
    }
    public setRoot(v: string): this {
        this.root = v;
        return this;
    }
    public setDir(v: string): this {
        this.dir = v;
        return this;
    }
    public setBase(v: string): this {
        this.base = v;
        return this;
    }
    public setExt(v: string): this {
        this.ext = v;
        return this;
    }
    public setName(v: string): this {
        this.name = v;
        return this;
    }
    public root: string;
    public dir: string;
    public base: string;
    public ext: string;
    public name: string
    constructor(path:string) {
        Object.assign(this,Path.parse(path))
    }
}


Object.assign(module.exports, {
    parse: binding.parse,
    format: binding.format,
    extname: binding.extname,
    basename: binding.basename,
    dirname: binding.dirname,
    relative: binding.relative,
    isAbsolute: binding.isAbsolute,
    resolve: binding.resolve,
    normalize: binding.normalize,
    join: binding.join,
});